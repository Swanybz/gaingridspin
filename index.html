<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GainGrid Spin & Win</title>

  <!-- Monetag SDK -->
  <script src='//libtl.com/sdk.js' data-zone='10176108' data-sdk='show_10176108'></script>

  <!-- retained SDK stubs (your environment) -->
  <script src="/_sdk/data_sdk.js"></script>
  <script src="/_sdk/element_sdk.js"></script>

  <style>
    /* ---------- KEEP ALL YOUR ORIGINAL STYLES (unchanged) ---------- */
    body { box-sizing: border-box; margin:0; padding:0; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #4a148c 0%, #880e4f 100%); color:#fff; min-height:100%; overflow-x:hidden; }
    *{box-sizing:border-box}
    .container{max-width:600px;margin:0 auto;padding:20px}
    .header{text-align:center;margin-bottom:30px;padding:20px}
    .header h1{font-size:32px;margin:0 0 10px 0;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
    .header p{font-size:16px;margin:0;opacity:0.9}
    .wheel-container{position:relative;width:100%;max-width:400px;margin:0 auto 30px;aspect-ratio:1;perspective:1200px}
    .wheel{width:100%;height:100%;border-radius:50%;position:relative;box-shadow:0 12px 50px rgba(0,0,0,0.55), 0 0 60px rgba(0,0,0,0.2) inset;transition:transform 4s cubic-bezier(0.17,0.67,0.12,0.99);border:12px solid rgba(255,215,0,0.15);transform-style:preserve-3d;background:linear-gradient(145deg, rgba(255,255,255,0.03), rgba(0,0,0,0.12))}
    .wheel-segment{position:absolute;width:50%;height:50%;transform-origin:100% 100%;clip-path:polygon(0 0,100% 0,100% 100%);display:flex;align-items:flex-start;justify-content:center;font-size:11px;font-weight:bold;text-align:center;padding:15px 5px 5px 5px;overflow:hidden;backface-visibility:hidden}
    .segment-text{transform:rotate(-90deg) translateX(-20px);white-space:nowrap;text-shadow:1px 1px 2px rgba(0,0,0,0.5)}
    .wheel-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) translateZ(60px);width:80px;height:80px;background:linear-gradient(135deg,#ffd700,#ffed4e);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:24px;box-shadow:0 10px 40px rgba(0,0,0,0.45), inset 0 6px 18px rgba(255,255,255,0.25);z-index:50}
    .wheel-pointer{position:absolute;top:-20px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:20px solid transparent;border-right:20px solid transparent;border-top:40px solid #ec407a;z-index:60;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.3))}
    .vip-status{background:rgba(255,255,255,0.06);border-radius:15px;padding:20px;margin-bottom:25px;text-align:center;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.06)}
    .vip-status h3{margin:0 0 10px 0;font-size:20px;color:#ffd700}
    .vip-status p{margin:0;font-size:14px;line-height:1.5}
    .controls{background:rgba(255,255,255,0.06);border-radius:15px;padding:25px;margin-bottom:25px;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.06)}
    .progress-bar{margin-bottom:20px}
    .progress-label{display:flex;justify-content:space-between;margin-bottom:8px;font-size:14px;font-weight:bold}
    .progress-track{width:100%;height:12px;background:rgba(0,0,0,0.25);border-radius:6px;overflow:hidden}
    .progress-fill{height:100%;background:linear-gradient(90deg,#00e5ff,#ffd700);border-radius:6px;transition:width 0.3s ease}
    .button{width:100%;padding:16px;margin-bottom:12px;border:none;border-radius:12px;font-size:16px;font-weight:bold;cursor:pointer;transition:all 0.3s ease;box-shadow:0 6px 25px rgba(0,0,0,0.4)}
    .button:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 8px 30px rgba(0,0,0,0.45)}
    .button:active:not(:disabled){transform:translateY(0)}
    .button:disabled{opacity:0.5;cursor:not-allowed}
    .button-primary{background:linear-gradient(135deg,#8e24aa,#ab47bc);color:white}
    .button-secondary{background:linear-gradient(135deg,#ec407a,#f06292);color:white}
    .button-tertiary{background:rgba(255,255,255,0.12);color:white;border:2px solid rgba(255,255,255,0.12)}
    .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;align-items:center;justify-content:center;padding:20px}
    .modal.active{display:flex}
    .modal-content{background:linear-gradient(135deg,#4a148c,#880e4f);border-radius:20px;padding:40px;max-width:400px;width:100%;text-align:center;box-shadow:0 10px 40px rgba(0,0,0,0.5);border:3px solid #ffd700;animation:modalPop 0.3s ease}
    @keyframes modalPop{0%{transform:scale(0.8);opacity:0}100%{transform:scale(1);opacity:1}}
    .modal-content h2{font-size:28px;margin:0 0 15px 0;color:#ffd700}
    .modal-content p{font-size:18px;margin:0 0 25px 0;line-height:1.5}
    .footer{text-align:center;padding:30px 20px;margin-top:40px;border-top:2px solid rgba(255,255,255,0.08)}
    .footer p{margin:5px 0;font-size:14px;opacity:0.8}
    .loading{display:inline-block;width:20px;height:20px;border:3px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Flying gift box */
    .gift-box{position:fixed;width:70px;height:70px;right:12%;top:18%;z-index:120;border-radius:10px;display:none;align-items:center;justify-content:center;cursor:pointer;transform-style:preserve-3d;perspective:1000px}
    .gift-inner{width:100%;height:100%;border-radius:10px;background:linear-gradient(135deg,#fff,#ffd3ff);color:#4a148c;display:flex;align-items:center;justify-content:center;font-weight:800;box-shadow:0 10px 30px rgba(0,0,0,0.45);transform-origin:center}
    .gift-3d{animation:flyAround 10s linear infinite, floatY 3s ease-in-out infinite;transform-style:preserve-3d}
    @keyframes floatY{0%{transform:translateZ(0) translateY(0) rotateX(0) rotateY(0)}50%{transform:translateZ(12px) translateY(-6px) rotateX(6deg) rotateY(3deg)}100%{transform:translateZ(0) translateY(0) rotateX(0) rotateY(0)}}
    @keyframes flyAround{0%{right:10%;top:10%;transform:translateZ(0) rotateY(0)}25%{right:60%;top:12%;transform:translateZ(18px) rotateY(30deg)}50%{right:55%;top:65%;transform:translateZ(6px) rotateY(60deg)}75%{right:12%;top:62%;transform:translateZ(18px) rotateY(90deg)}100%{right:10%;top:10%;transform:translateZ(0) rotateY(0)}}

    /* popunder small iframe under UI (new) */
    .popunder {
      position: fixed;
      left: 50%;
      transform: translateX(-50%) translateY(200px);
      bottom: 12px;
      width: 320px;
      height: 170px;
      background: #fff;
      color: #000;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 40px rgba(0,0,0,0.6);
      z-index: 150;
      transition: transform 0.35s ease, opacity 0.35s ease;
      opacity: 0;
      display: flex;
      flex-direction: column;
    }
    .popunder.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
    .popunder .pu-bar { display:flex; justify-content:space-between; align-items:center; padding:8px; background:#f5f5f5; }
    .popunder .pu-bar button { background: #ec407a; color:#fff; border:none; padding:6px 10px; border-radius:8px; cursor:pointer; }
    .popunder iframe { flex:1; border:none; width:100%; height:100%; }

    @media (max-width:480px){.header h1{font-size:24px}.header p{font-size:14px}.wheel-container{max-width:300px}.wheel-segment{font-size:9px;padding:12px 3px 3px 3px}.segment-text{transform:rotate(-90deg) translateX(-15px)}.modal-content{padding:30px 20px}.modal-content h2{font-size:24px}.modal-content p{font-size:16px}.gift-box{width:58px;height:58px}}
  </style>

  <style>@view-transition { navigation: auto; }</style>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="container">
   <div class="header">
    <h1 id="main-title">üé° Spin &amp; Win G-Coins!</h1>
    <p id="subtitle">Unlock rewards, rare VIPs, and bonuses. Spin 10x daily!</p>
   </div>

   <div class="wheel-container">
    <div class="wheel-pointer"></div>
    <div class="wheel" id="wheel"></div>
    <div class="wheel-center">üé°</div>
   </div>

   <div class="vip-status" id="vip-status">
    <h3>VIP Status</h3>
    <p id="vip-message">Loading...</p>
   </div>

   <div class="controls">
    <div class="progress-bar">
     <div class="progress-label"><span>Daily Spins</span> <span id="spins-count">0/10</span></div>
     <div class="progress-track"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
    </div>
    <button class="button button-primary" id="spin-button"> üåÄ Spin Now </button>
    <button class="button button-tertiary" id="refresh-button"> üîÑ Refresh Wheel </button>
   </div>
  </div>

  <!-- Flying gift box -->
  <div class="gift-box" id="giftBox" title="Lucky Gift ‚Äî click to open">
    <div class="gift-inner gift-3d" id="giftInner">üéÅ</div>
  </div>

  <!-- Popunder small iframe (new) -->
  <div class="popunder" id="popunder">
    <div class="pu-bar">
      <div style="font-weight:700;padding-left:8px;">Sponsored</div>
      <div style="display:flex;gap:8px;padding-right:8px;">
        <button id="pu-close">Close</button>
      </div>
    </div>
    <iframe id="popunder-frame" src="" sandbox=""></iframe>
  </div>

  <div class="footer">
   <p id="footer-text">¬© GainGrid 2025 | All rights reserved</p>
   <p id="support-links">Telegram Support | Privacy Policy</p>
  </div>

  <div class="modal" id="result-modal">
   <div class="modal-content">
    <h2 id="modal-title">üéâ Congratulations!</h2>
    <p id="modal-message">You won something amazing!</p>
    <button class="button button-primary" id="modal-close">Continue</button>
   </div>
  </div>
  
<script>
  (function(){
    // ---------- CONFIG & CONSTANTS ----------
    const AD_COOLDOWN_MS = 5000; // 5s between popunders/actions
    const VIP_ELIGIBLE_DAYS = 3;  // VIP shows only after this many days
    const MAX_DAILY_SPINS = 10;
    const SMARTLINK_1 = 'https://otieu.com/4/10176185';
    const SMARTLINK_2 = 'https://otieu.com/4/10176155';
    const POPUNDER_INTERVAL_MS = 5000; // popunder every 5 seconds (as requested)

    // ---------- DEFAULT UI DATA ----------
    const defaultConfig = {
      main_title: "üé° Spin & Win G-Coins!",
      subtitle: "Unlock rewards, rare VIPs, and bonuses. Spin 10x daily!",
      footer_text: "¬© GainGrid 2025 | All rights reserved",
      support_links: "Telegram Support | Privacy Policy"
    };

    const wheelSegmentsBase = [
      { key:'coins_50', text: "+50 G-Coins", color: "#8e24aa", value: 50, type: "coins" },
      { key:'coins_100', text: "+100 G-Coins", color: "#ab47bc", value: 100, type: "coins" },
      { key:'coins_200', text: "+200 G-Coins", color: "#ba68c8", value: 200, type: "coins" },
      { key:'mystery', text: "üéÅ Mystery Box", color: "#ce93d8", value: 0, type: "mystery" },
      { key:'vip_basic', text: "ü•â Basic VIP", color: "#ffd700", value: 0, type: "vip_basic" },
      { key:'nothing', text: "Try Again", color: "#ec407a", value: 0, type: "nothing" },
      { key:'double', text: "üîÅ Spin x2", color: "#f06292", value: 0, type: "double_spin" },
      { key:'mult', text: "üî• Bonus x2", color: "#f48fb1", value: 0, type: "multiplier" },
      { key:'cool', text: "üßä Cooldown Cut", color: "#00e5ff", value: 0, type: "cooldown" },
      { key:'coins_500', text: "+500 G-Coins", color: "#9c27b0", value: 500, type: "coins" }
    ];

    // ---------- state (preserve original names) ----------
    let currentSegments = [];
    let userData = null;             // persisted via dataSdk or seeded from deeplink
    let isSpinning = false;
    let telegramUserId = null;
    let incomingPayload = null;
    let autoStartRequested = false;
    let lastAdCloseAt = 0;

    // NEW: staged results/session tracking (3-spin session)
    let stagedSpinCount = 0; // counts spins in current "batch" before sending to bot (kept name)
    let stagedResults = [];  // array to accumulate each spin's payload (new)
    // userData.pending_watch_ad will be used to flag the UI to show watch ad to unlock next spin
    // userData.gift_box_claimed_date tracks gift usage per-day

    // ---------- helpers ----------
    function safeText(resp){ try { return resp ? resp.text() : null; } catch(e){ return null; } }

    // Hardened base64/json parser (keeps original)
    function tryParseJSONorB64(input) {
      if (input === undefined || input === null) return null;
      if (typeof input === 'object') return input;
      let s = String(input).trim();

      // Direct JSON
      if ((s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'))) {
        try { return JSON.parse(s); } catch(e){}
      }

      // URL-decoded JSON
      try {
        const dec = decodeURIComponent(s);
        if ((dec.startsWith('{') && dec.endsWith('}')) || (dec.startsWith('[') && dec.endsWith(']'))) {
          return JSON.parse(dec);
        }
      } catch(e){}

      // Strings wrapped in quotes -> unwrap and retry
      try {
        if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
          const unq = s.substring(1, s.length-1);
          const tryInner = tryParseJSONorB64(unq);
          if (tryInner) return tryInner;
        }
      } catch(e){}

      // Base64 (URL-safe)
      try {
        let b = s.replace(/-/g,'+').replace(/_/g,'/');
        try { b = decodeURIComponent(b); } catch(e){}
        b = b + '='.repeat((4 - (b.length % 4)) % 4);
        let raw = atob(b);
        try { raw = decodeURIComponent(escape(raw)); } catch(e){}
        if ((raw.startsWith('{') && raw.endsWith('}')) || (raw.startsWith('[') && raw.endsWith(']'))) {
          return JSON.parse(raw);
        }
        const nested = tryParseJSONorB64(raw);
        if (nested) return nested;
        return raw;
      } catch(e){}

      // fallback: try atob directly
      try {
        let raw = atob(s);
        try { raw = decodeURIComponent(escape(raw)); } catch(e){}
        const nested = tryParseJSONorB64(raw);
        if (nested) return nested;
        if ((raw.startsWith('{') && raw.endsWith('}')) || (raw.startsWith('[') && raw.endsWith(']'))) {
          return JSON.parse(raw);
        }
        return raw;
      } catch(e){}

      return null;
    }

    function parseDeeplinkPayload() {
      try {
        const qs = new URLSearchParams(location.search || '');
        const candidates = [];

        ['start','data','s','p','payload'].forEach(k => { const v = qs.get(k); if (v) candidates.push(v); });

        if (location.hash) {
          let rawHash = location.hash.replace(/^#/,'');
          if (rawHash.includes('?')) {
            const hashQs = rawHash.split('?').slice(1).join('?');
            const hparams = new URLSearchParams(hashQs);
            ['start','data','s','p','payload'].forEach(k => { const v = hparams.get(k); if (v) candidates.push(v); });
          } else {
            candidates.push(rawHash);
          }
        }

        if (location.search && location.search.length > 1) {
          candidates.push(location.search.replace(/^\?/,''));
        }

        for (const c of candidates) {
          if (!c) continue;
          const parsed = tryParseJSONorB64(c);
          if (parsed && typeof parsed === 'object') {
            try { sessionStorage.setItem('gainGridUserData', JSON.stringify(parsed)); } catch(e){}
            return parsed;
          }
        }

        const cached = sessionStorage.getItem('gainGridUserData');
        if (cached) {
          try { return JSON.parse(cached); } catch(e){}
        }
        return null;
      } catch(e) { console.warn('parseDeeplinkPayload err', e); return null; }
    }

    // Post wrapper to bot callback or fallback webhook
    async function postToCallbackOrWebhook(wrapper, callbackUrlCandidate) {
      try {
        const candidate = callbackUrlCandidate || (incomingPayload && (incomingPayload.callback_url || incomingPayload.callbackUrl || incomingPayload.webhook || incomingPayload.callbackurl)) || '<% options.url %>';
        if (!candidate) { console.warn('No webhook/callback url to post to.'); return { ok:false, error:'no_target' }; }
        const resp = await fetch(candidate, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(wrapper),
          keepalive: true
        });
        return { ok: resp && resp.ok, status: resp && resp.status, text: await safeText(resp) };
      } catch(e){
        console.error('postToCallbackOrWebhook err', e);
        return { ok:false, error:String(e) };
      }
    }

    async function postToBotWebhook(wrapper) {
      return postToCallbackOrWebhook(wrapper, null);
    }

    // VIP display eligibility
    function vipEligibleToShow(user) {
      try {
        const t = user && user.vip_first_seen_time;
        if (!t) {
          if (user) user.vip_first_seen_time = new Date().toISOString();
          if (window.dataSdk && user && user.id) { window.dataSdk.update(user).catch(()=>{}); }
          return false;
        } else {
          const days = (Date.now() - new Date(t).getTime()) / (1000*60*60*24);
          return days >= VIP_ELIGIBLE_DAYS;
        }
      } catch(e){ return false; }
    }

    function buildSegmentsForUser(user) {
      const segs = [...wheelSegmentsBase];
      if (user && user.vip_status && user.vip_status !== 'free' && vipEligibleToShow(user)) {
        segs.splice(Math.max(1, Math.floor(segs.length/2)), 0, { key:'vip_shiny', text:'üíé VIP RARE', color:'#ffd700', value:0, type:'vip_shiny' });
      }
      return segs;
    }

    // ---------- UI RENDER ----------
    function shuffleWheel() {
      if (!Array.isArray(currentSegments) || currentSegments.length === 0) currentSegments = buildSegmentsForUser(userData);
      currentSegments = buildSegmentsForUser(userData).sort(()=>Math.random()-0.5);
    }

    function renderWheel() {
      const wheel = document.getElementById('wheel');
      if (!wheel) return;
      wheel.innerHTML = '';
      if (!Array.isArray(currentSegments) || currentSegments.length === 0) currentSegments = buildSegmentsForUser(userData) || wheelSegmentsBase.slice();
      const segmentAngle = 360 / currentSegments.length;
      currentSegments.forEach((segment, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'wheel-segment';
        segmentDiv.style.background = segment.color;
        segmentDiv.style.transform = `rotate(${index * segmentAngle}deg) skewY(${-(90 - segmentAngle)}deg) translateZ(0)`;
        const textSpan = document.createElement('span');
        textSpan.className = 'segment-text';
        textSpan.textContent = segment.text;
        segmentDiv.appendChild(textSpan);
        wheel.appendChild(segmentDiv);
      });
    }

    function maybeShowGiftBox() {
      const gift = document.getElementById('giftBox');
      if (!gift) return;
      if (!userData) { gift.style.display = 'none'; return; }
      // show only if user has used 9 spins (9/10) and gift not claimed today
      const spinsUsed = userData.spins_used || 0;
      const claimedDate = userData.gift_box_claimed_date || null;
      const today = new Date().toISOString().split('T')[0];
      if (spinsUsed === (MAX_DAILY_SPINS - 1) && claimedDate !== today) gift.style.display = 'flex'; else gift.style.display = 'none';
    }

    function showModal(title, message) {
      const modal = document.getElementById('result-modal');
      if (!modal) return;
      document.getElementById('modal-title').textContent = title;
      document.getElementById('modal-message').textContent = message;
      modal.classList.add('active');
    }
    function closeModal() {
      const modal = document.getElementById('result-modal');
      if (!modal) return;
      modal.classList.remove('active');
    }

    // ---------- Deeplink auto-validation & incoming payload ----------
    function startAutoValidationFlow(payload) {
      try {
        if (!payload) return;
        incomingPayload = payload;
        const secs = Number(payload.secs || payload.seconds || payload.duration || 0);
        const adId = payload.ad_id || payload.adid || payload.id;
        const userId = payload.user_id || (payload.user && payload.user.user_id) || payload.userid || payload.userId;
        window.__gaingrid_incoming = payload;

        if (secs > 0) {
          const el = document.getElementById('vip-message');
          if (el) el.textContent = `Ad playing... (${secs}s) ‚Äî will auto-validate when done.`;
          let remaining = secs;
          const interval = setInterval(()=> {
            remaining--;
            if (el) el.textContent = `Ad playing... (${Math.max(0,remaining)}s) ‚Äî will auto-validate when done.`;
            if (remaining <= 0) clearInterval(interval);
          },1000);
          setTimeout(async ()=>{
            const wrapper = { action:'ads_validate', payload:{ ad_id:adId, user_id:userId, status:'ad_complete', secs:secs, reward:payload.reward||null, ts:new Date().toISOString() }, meta:{ from_hosted:true, auto:true } };
            const res = await postToCallbackOrWebhook(wrapper, payload.callback_url || payload.webhook);
            console.log('auto validation POST result', res);
            try { const vipEl = document.getElementById('vip-message'); if (vipEl) vipEl.textContent = 'Ad validated ‚Äî thank you!'; } catch(e){}
            if (res && res.ok) { showModal('‚úÖ Ad Verified','Thanks ‚Äî reward will be credited shortly.'); setTimeout(()=>{ closeModal(); try{ if (window.Telegram && Telegram.WebApp) Telegram.WebApp.close(); } catch(e){} },1400); }
            else showModal('‚ö†Ô∏è Validation Failed','Could not notify bot. Please try again or contact support.');
          }, secs*1000 + 300);
        } else {
          if (payload.start === true || payload.start === 'true' || payload.start_immediately === true) autoStartRequested = true;
        }

        setupSkipOnClose(payload);
      } catch(e){ console.error('startAutoValidationFlow err', e); }
    }

    function setupSkipOnClose(payload) {
      let alreadySent = false;
      const callback = payload && (payload.callback_url || payload.callbackUrl || payload.webhook || payload.callbackurl);
      function handler(e) {
        try {
          if (alreadySent) return;
          alreadySent = true;
          const adId = payload.ad_id || payload.adid || payload.id;
          const userId = payload.user_id || (payload.user && payload.user.user_id) || payload.userid || payload.userId;
          const wrapper = { action:'ads_validate', payload:{ ad_id:adId, user_id:userId, status:'ad_skipped', ts:new Date().toISOString() }, meta:{ from_hosted:true, reason:'closed' } };
          try {
            const target = callback || (incomingPayload && (incomingPayload.callback_url||incomingPayload.webhook)) || '<% options.url %>';
            const blob = new Blob([JSON.stringify(wrapper)], { type: 'application/json' });
            if (navigator && navigator.sendBeacon) navigator.sendBeacon(target, blob);
            else fetch(target, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(wrapper), keepalive:true });
          } catch(err){ console.warn('skip-on-close post failed', err); }
        } catch(e){}
      }
      window.addEventListener('beforeunload', handler);
      window.addEventListener('pagehide', handler);
    }

    // ---------- dataSdk handler ----------
    const dataHandler = {
      onDataChanged(data) {
        try {
          if (data && data.length > 0) {
            userData = data[0];
            userData.spins_used = Number(userData.spins_used || 0);
            userData.total_coins_won = Number(userData.total_coins_won || 0);
            userData.vip_status = (userData.vip_status || 'free').toString().toLowerCase();
            // ensure day reset check (we'll also call checkDailyReset regularly)
            checkDailyReset();
            shuffleWheel();
            renderWheel();
            updateUI();
            maybeShowGiftBox();
          }
        } catch(e){ console.error('dataHandler.onDataChanged err', e); }
      }
    };

    function getTelegramUserIdFromWebApp() {
      try { if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) return Telegram.WebApp.initDataUnsafe.user.id; } catch(e){}
      return null;
    }

    // ---------- initialization ----------
    async function initializeApp() {
      const incoming = parseDeeplinkPayload();
      if (incoming) {
        console.log('Deeplink payload detected:', incoming);
        incomingPayload = incoming;
        if (incoming.vip_level || incoming.vipLevel) {
          if (!userData) userData = {};
          if (!userData.vip_status || userData.vip_status === 'free') userData.vip_status = (incoming.vip_level || incoming.vipLevel).toString().toLowerCase();
        }
        if (incoming.user_id || incoming.userid || (incoming.user && incoming.user.user_id)) {
          telegramUserId = incoming.user_id || incoming.userid || (incoming.user && incoming.user.user_id) || telegramUserId;
        }
        if (incoming.start === true || incoming.start === 'true' || incoming.start_immediately === true) autoStartRequested = true;
        startAutoValidationFlow(incoming);
      }

      const twId = getTelegramUserIdFromWebApp();
      if (twId) telegramUserId = twId;

      let initResult = { isOk: false };
      if (window.dataSdk && typeof window.dataSdk.init === 'function') {
        try { initResult = await window.dataSdk.init(dataHandler); } catch(e){ initResult = { isOk:false }; console.warn('dataSdk.init err', e); }
      } else {
        console.warn('dataSdk not present, using in-page fallback');
      }

      if (!initResult || !initResult.isOk) {
        console.warn("dataSdk failed ‚Äî using fallback in-page state");
        const today = new Date().toISOString().split('T')[0];
        userData = userData || {
          id: (incomingPayload && (incomingPayload.user_id || incomingPayload.userid)) || "user_spin_fallback",
          spins_used: Number((incomingPayload && (incomingPayload.spins_used || incomingPayload.daily_spins)) || 0),
          last_reset_date: today,
          total_coins_won: Number((incomingPayload && incomingPayload.points) || 0),
          vip_status: (incomingPayload && (incomingPayload.vip_level || incomingPayload.vipLevel)) ? String(incomingPayload.vip_level || incomingPayload.vipLevel).toLowerCase() : "free",
          vip_expiry: "",
          vip_first_seen_time: (incomingPayload && incomingPayload.vip_first_seen_time) ? incomingPayload.vip_first_seen_time : null,
          pending_watch_ad: false,
          gift_box_claimed_date: null,
          pending_bonus: 0
        };

        // ensure persisted fallback in sessionStorage
        try { sessionStorage.setItem('gainGridUserData', JSON.stringify(userData)); } catch(e){}

        shuffleWheel();
        renderWheel();
        setupEventListeners();
        updateUI();
        maybeShowGiftBox();

        if (autoStartRequested && (userData.spins_used || 0) < MAX_DAILY_SPINS) {
          setTimeout(()=>{ spinWheel(); }, 600);
        }

        scheduleSmartlinksLoad();
        startPopunderLoop(); // start popunder showing loop
        return;
      }

      // if dataSdk works, try to ensure there's userData
      if (!userData) {
        try {
          const today = new Date().toISOString().split('T')[0];
          const createResult = await window.dataSdk.create({ id: "user_spin_data", spins_used:0, last_reset_date:today, total_coins_won:0, vip_status:"free", vip_expiry:"", vip_first_seen_time: null, pending_watch_ad:false, gift_box_claimed_date:null, pending_bonus:0 }).catch(()=>({ isOk:false }));
          if (createResult && createResult.isOk) userData = createResult.data;
        } catch(e){ console.warn('dataSdk.create err', e); }
      }

      if (!userData && window.dataSdk && typeof window.dataSdk.query === 'function') {
        try {
          const list = await window.dataSdk.query();
          if (Array.isArray(list) && list.length) userData = list[0];
        } catch(e){ /* ignore */ }
      }

      if (!userData) {
        const today = new Date().toISOString().split('T')[0];
        userData = { id:"user_spin_fallback", spins_used:0, last_reset_date:today, total_coins_won:0, vip_status:"free", vip_expiry:"", vip_first_seen_time: null, pending_watch_ad:false, gift_box_claimed_date:null, pending_bonus:0 };
      }

      shuffleWheel();
      renderWheel();
      setupEventListeners();
      updateUI();
      maybeShowGiftBox();

      if (autoStartRequested && userData && (userData.spins_used || 0) < MAX_DAILY_SPINS) {
        setTimeout(()=>{ spinWheel(); }, 600);
      }

      scheduleSmartlinksLoad();
      startPopunderLoop(); // start popunder showing loop
    }

    // ---------- daily reset ----------
    function checkDailyReset() {
      if (!userData) return;
      const today = new Date().toISOString().split('T')[0];
      if (userData.last_reset_date !== today) {
        userData.spins_used = 0;
        userData.last_reset_date = today;
        userData.gift_box_claimed_date = null;
        userData.pending_watch_ad = false;
        userData.pending_bonus = userData.pending_bonus || 0;
        stagedSpinCount = 0;
        stagedResults = [];
        // persist
        if (window.dataSdk && typeof window.dataSdk.update === 'function') {
          window.dataSdk.update(userData).catch(()=>{});
        } else {
          try { sessionStorage.setItem('gainGridUserData', JSON.stringify(userData)); } catch(e){}
        }
      }
    }

    // ---------- process win & callback ----------
    async function processWin(segment) {
      if (!userData) return;
      // increment spin used
      userData.spins_used = (userData.spins_used || 0) + 1;
      stagedSpinCount++;
      // Build per-spin payload (do not send individual spin_result immediately; queue instead)
      const perSpinPayload = {
        segment_type: segment.type,
        value: segment.value || 0,
        text: segment.text,
        ts: new Date().toISOString()
      };

      // Compute outcomes (update userData as original logic did)
      let modalTitle = "üéâ Congratulations!";
      let modalMessage = "";

      switch(segment.type) {
        case "coins":
          // apply multiplier if present
          const multiplier = userData.next_multiplier || 1;
          const coinsWon = (segment.value || 0) * multiplier;
          userData.total_coins_won = (userData.total_coins_won || 0) + coinsWon;
          perSpinPayload.value = coinsWon;
          if (multiplier > 1) { userData.next_multiplier = 1; } // consume multiplier
          modalTitle = "üí∞ You Won!";
          modalMessage = `You won +${coinsWon} G-Coins!\n‚úÖ Credited to your wallet`;
          break;
        case "vip_basic":
          userData.vip_status = "basic";
          const expiry = new Date(); expiry.setDate(expiry.getDate()+7);
          userData.vip_expiry = expiry.toISOString();
          modalTitle = "üëë VIP Unlocked!";
          modalMessage = "You won ü•â Basic VIP (7-day access)\n‚úÖ Activated now!";
          break;
        case "vip_shiny":
          userData.vip_status = "platinum";
          const exp = new Date(); exp.setDate(exp.getDate()+14);
          userData.vip_expiry = exp.toISOString();
          modalTitle = "üíé Legendary VIP!";
          modalMessage = "You won a rare VIP! üéâ 14-day access granted.";
          break;
        case "mystery":
          const mysteryCoins = Math.floor(Math.random()*300)+100;
          userData.total_coins_won = (userData.total_coins_won || 0) + mysteryCoins;
          perSpinPayload.value = mysteryCoins;
          modalTitle = "üéÅ Mystery Box!";
          modalMessage = `You found +${mysteryCoins} G-Coins inside!\n‚úÖ Credited to your wallet`;
          break;
        case "double_spin":
          // give an extra spin by reducing spins_used by 1 (so net doesn't count this spin)
          userData.spins_used = Math.max(0, userData.spins_used - 1);
          modalTitle = "üîÅ Bonus Spin!";
          modalMessage = "You won an extra spin!\n‚úÖ Spin again now!";
          // record pending bonus as +1 to be included in next batch logic if needed
          userData.pending_bonus = (userData.pending_bonus || 0) + 1;
          break;
        case "multiplier":
          userData.next_multiplier = (userData.next_multiplier || 1)*2;
          modalTitle = "üî• Multiplier Active!";
          modalMessage = "Your next coin win will be doubled!\n‚úÖ Spin again to activate!";
          break;
        case "cooldown":
          userData.cooldown_cut = true;
          modalTitle = "üßä Cooldown Cut!";
          modalMessage = "Spin cooldown reduced!\n‚úÖ Spin faster now!";
          break;
        case "nothing":
        default:
          modalTitle = "üòÖ Try Again!";
          modalMessage = "Better luck next time!\nüé° Keep spinning for rewards!";
          break;
      }

      // push per-spin payload into stagedResults for batch sending
      stagedResults.push(perSpinPayload);

      // Persist userData immediately
      try {
        if (window.dataSdk && typeof window.dataSdk.update === 'function') {
          await window.dataSdk.update(userData).catch(()=>({ isOk:false }));
        } else {
          try { sessionStorage.setItem('gainGridUserData', JSON.stringify(userData)); } catch(e){}
        }
      } catch(e){ console.warn('dataSdk.update err', e); }

      // We still log an individual spin_result to webhook if you want real-time, but per your requirement
      // the aggregate (3-spin) results should be sent only after 3 spins, so we will only send batch.
      // If you still want individual spin_result sent, uncomment the following:
      // await postToBotWebhook({ action:'spin_result', payload:{ user_id:telegramUserId || userData.id, ...perSpinPayload, spins_used:userData.spins_used }, meta:{ from_frontend:true } });

      showModal(modalTitle, modalMessage);
      maybeShowGiftBox();
      updateUI();

      // If we've collected 3 spins, send batch aggregate to bot, then set pending_watch_ad to true
      if (stagedSpinCount >= 3) {
        // Calculate aggregate
        const aggregateValue = stagedResults.reduce((acc, r) => acc + (r.value || 0), 0);
        const batchWrapper = {
          action: 'spin_batch',
          payload: {
            user_id: telegramUserId || (userData && (userData.telegram_id || userData.id)) || null,
            batch_spins: stagedSpinCount,
            spins_used: userData.spins_used,
            total_coins_won: userData.total_coins_won || 0,
            aggregate_value: aggregateValue,
            details: stagedResults.slice(),
            ts: new Date().toISOString()
          },
          meta: { from_frontend: true }
        };
        try {
          await postToBotWebhook(batchWrapper);
        } catch(e){ console.warn('batch post err', e); }

        // After sending batch, set flag to require watch ad before unlocking next spin (if daily limit not reached)
        userData.pending_watch_ad = true;
        // persist pending flag
        if (window.dataSdk && typeof window.dataSdk.update === 'function') {
          try { await window.dataSdk.update(userData).catch(()=>{}); } catch(e){}
        } else {
          try { sessionStorage.setItem('gainGridUserData', JSON.stringify(userData)); } catch(e){}
        }

        // Reset staged counters for next session/level
        stagedSpinCount = 0;
        stagedResults = [];
        // reflect UI change (show watch ad to unlock if applicable)
        updateUI();
      }

      // If user hit daily limit exactly now, send daily_spin_complete
      if ((userData.spins_used || 0) >= MAX_DAILY_SPINS) {
        const finalWrapper = {
          action: 'daily_spin_complete',
          payload: {
            user_id: telegramUserId || (userData && (userData.telegram_id || userData.id)) || null,
            vip_status: userData.vip_status || 'free',
            spins_used: userData.spins_used || MAX_DAILY_SPINS,
            total_coins_won: userData.total_coins_won || 0,
            pending_bonus: userData.pending_bonus || 0,
            ts: new Date().toISOString()
          },
          meta: { from_frontend: true }
        };
        try { await postToBotWebhook(finalWrapper); } catch(e){ console.warn('final post err', e); }
      }
    }

    // ---------- spin implementation ----------
    async function spinWheel() {
      if (isSpinning || !userData || (userData.spins_used >= MAX_DAILY_SPINS)) return;
      isSpinning = true;
      const spinButton = document.getElementById('spin-button');
      if (spinButton) { spinButton.disabled = true; spinButton.innerHTML = '<span class="loading"></span>'; }

      if (!Array.isArray(currentSegments) || currentSegments.length === 0) currentSegments = buildSegmentsForUser(userData);
      const wheel = document.getElementById('wheel');
      const segmentAngle = 360 / Math.max(1, currentSegments.length);
      const randomIndex = Math.floor(Math.random() * currentSegments.length);
      const targetRotation = 360 * 5 + (randomIndex * segmentAngle) + (segmentAngle / 2);

      if (wheel) {
        wheel.style.transition = 'transform 4s cubic-bezier(0.17,0.67,0.12,0.99)';
        wheel.style.transform = `rotate(${targetRotation}deg) translateZ(0)`;
      }

      setTimeout(async () => {
        const winningSegment = currentSegments[randomIndex] || currentSegments[0];
        await processWin(winningSegment);
        if (wheel) {
          wheel.style.transition = 'none';
          wheel.style.transform = 'rotate(0deg)';
          setTimeout(()=>{ if (wheel) wheel.style.transition = 'transform 4s cubic-bezier(0.17,0.67,0.12,0.99)'; },50);
        }
        isSpinning = false;
        if (spinButton) spinButton.innerHTML = 'üåÄ Spin Now';
        updateUI();
      },4000);
    }

    // ---------- watchAd flow ----------
    async function watchAdFlow() {
      try {
        showModal("üì∫ Watching Ad...", "Please wait while the ad plays...\n‚è≥ This will take a few seconds");
        if (typeof show_10176108 === 'function') {
          await show_10176108('pop');
        } else {
          // simple simulated wait
          await new Promise(res=>setTimeout(res,3000));
        }

        // After ad completes: unlock one spin if user hasn't hit daily limit
        if (userData) {
          // only unlock a spin if pending_watch_ad is true and user hasn't hit daily limit
          if (userData.pending_watch_ad) {
            userData.pending_watch_ad = false;
            userData.spins_used = Math.max(0, (userData.spins_used || 0) - 1);
            // persist
            if (window.dataSdk && typeof window.dataSdk.update === 'function') await window.dataSdk.update(userData).catch(()=>{});
            else try { sessionStorage.setItem('gainGridUserData', JSON.stringify(userData)); } catch(e){}
            // notify backend
            await postToCallbackOrWebhook({ action:'ad_reward', payload:{ user_id:telegramUserId||null, reward_spins:1, spins_used:userData.spins_used, ts:new Date().toISOString() }, meta:{from_frontend:true} }, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
            closeModal();
            showModal("‚úÖ Spin Unlocked!", "Ad watched successfully!\nüé° You earned 1 free spin!");
            setTimeout(()=>{ closeModal(); updateUI(); }, 1600);
            return;
          } else {
            // If not pending, still give a spin if daily limit allows (fallback)
            if ((userData.spins_used || 0) < MAX_DAILY_SPINS) {
              userData.spins_used = Math.max(0, (userData.spins_used || 0) - 1);
              if (window.dataSdk && typeof window.dataSdk.update === 'function') await window.dataSdk.update(userData).catch(()=>{});
              await postToCallbackOrWebhook({ action:'ad_reward', payload:{ user_id:telegramUserId||null, reward_spins:1, spins_used:userData.spins_used, ts:new Date().toISOString() }, meta:{from_frontend:true} }, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
              closeModal();
              showModal("‚úÖ Spin Unlocked!", "Ad watched successfully!\nüé° You earned 1 free spin!");
              setTimeout(()=>{ closeModal(); updateUI(); }, 1600);
              return;
            } else {
              closeModal();
              showModal("‚ÑπÔ∏è No Unlock Needed","You have reached your maximum spins for today.");
              setTimeout(()=>{ closeModal(); updateUI(); }, 1600);
              return;
            }
          }
        }
      } catch(e) {
        console.error('watchAd error', e);
        closeModal();
        showModal("‚ö†Ô∏è Ad Error","Could not show ad. Try again later.");
      }
    }

    // ---------- smartlink popunder (updated) ----------
    function openSmartAd(url) {
      // keep original overlay opener available, but we need a small popunder under UI ‚Äî use new popunder element instead
      try {
        // fallback to overlay if required
        const overlay = document.createElement('div');
        overlay.className = 'ad-overlay';
        overlay.style.position = 'fixed';
        overlay.style.left = 0; overlay.style.top = 0;
        overlay.style.width = '100%'; overlay.style.height = '100%';
        overlay.style.background = 'rgba(0,0,0,0.6)';
        overlay.style.zIndex = 2000;
        overlay.style.display = 'flex'; overlay.style.alignItems = 'center'; overlay.style.justifyContent = 'center';

        const container = document.createElement('div');
        container.style.width = '90%'; container.style.maxWidth = '520px'; container.style.height = '80%'; container.style.background = '#fff'; container.style.borderRadius = '12px'; container.style.overflow = 'hidden'; container.style.position = 'relative';

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.position = 'absolute'; closeBtn.style.top = '10px'; closeBtn.style.right = '10px'; closeBtn.style.zIndex = 10;

        const iframe = document.createElement('iframe');
        iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none';
        iframe.src = url;

        closeBtn.addEventListener('click', ()=> { document.body.removeChild(overlay); lastAdCloseAt = Date.now(); });

        container.appendChild(closeBtn);
        container.appendChild(iframe);
        overlay.appendChild(container);
        document.body.appendChild(overlay);
      } catch(e){ console.warn('openSmartAd fallback err', e); }
    }

    function scheduleSmartlinksLoad() {
      setTimeout(()=>{
        try {
          const iframe1 = document.createElement('iframe'); iframe1.style.display='none'; iframe1.src = SMARTLINK_1; document.body.appendChild(iframe1);
          setTimeout(()=>{ const iframe2 = document.createElement('iframe'); iframe2.style.display='none'; iframe2.src = SMARTLINK_2; document.body.appendChild(iframe2); },5000);
        } catch(e){ console.warn('scheduleSmartlinksLoad err', e); }
      },15000);
    }

    // ---------- Popunder small iframe logic (new) ----------
    let popunderTimer = null;
    let popunderVisible = false;
    function startPopunderLoop() {
      // show every POPUNDER_INTERVAL_MS (5s), re-show if closed
      stopPopunderLoop();
      popunderTimer = setInterval(()=> {
        try {
          // do not show while modal is active or data not ready
          const modal = document.getElementById('result-modal');
          if (modal && modal.classList.contains('active')) return;
          const pu = document.getElementById('popunder');
          const frame = document.getElementById('popunder-frame');
          if (!pu || !frame) return;
          // if already visible, do nothing
          if (!popunderVisible && (Date.now() - lastAdCloseAt >= AD_COOLDOWN_MS)) {
            frame.src = SMARTLINK_1; // load smartlink (change if you want alternate link)
            pu.classList.add('visible');
            popunderVisible = true;
          }
        } catch(e){}
      }, POPUNDER_INTERVAL_MS);
    }
    function stopPopunderLoop() {
      if (popunderTimer) { clearInterval(popunderTimer); popunderTimer = null; }
      const pu = document.getElementById('popunder');
      if (pu) { pu.classList.remove('visible'); }
      popunderVisible = false;
    }

    // close handler for popunder
    document.addEventListener('DOMContentLoaded', ()=> {
      try {
        const puClose = document.getElementById('pu-close');
        const pu = document.getElementById('popunder');
        if (puClose && pu) {
          puClose.addEventListener('click', ()=> {
            pu.classList.remove('visible');
            lastAdCloseAt = Date.now();
            popunderVisible = false;
            // it will reappear after POPUNDER_INTERVAL_MS because of startPopunderLoop
          });
        }
      } catch(e){}
    });

    // ---------- UI update ----------
    function updateUI() {
      try {
        // ensure daily reset check
        checkDailyReset();

        if (!userData) {
          const vipMessageEl = document.getElementById('vip-message');
          if (vipMessageEl) vipMessageEl.textContent = "Loading...";
          const spinsCountEl = document.getElementById('spins-count');
          if (spinsCountEl) spinsCountEl.textContent = `0/${MAX_DAILY_SPINS}`;
          const fill = document.getElementById('progress-fill');
          if (fill) fill.style.width = `0%`;
          return;
        }

        const spinsLeft = Math.max(0, MAX_DAILY_SPINS - (userData.spins_used || 0));
        const spinsCountEl = document.getElementById('spins-count');
        if (spinsCountEl) spinsCountEl.textContent = `${spinsLeft}/${MAX_DAILY_SPINS}`;
        const progressPercent = ((userData.spins_used || 0) / MAX_DAILY_SPINS) * 100;
        const progressFill = document.getElementById('progress-fill');
        if (progressFill) progressFill.style.width = `${progressPercent}%`;

        const spinButton = document.getElementById('spin-button');
        if (spinButton) {
          // New logic: show Watch Ad unlock only when a 3-spin session completed and pending_watch_ad = true
          if (userData.pending_watch_ad && (userData.spins_used || 0) < MAX_DAILY_SPINS) {
            spinButton.textContent = '‚ñ∂Ô∏è Watch Ad to Unlock Spin';
            spinButton.className = 'button button-secondary';
            spinButton.disabled = isSpinning;
            spinButton.onclick = watchAdFlow;
          } else if ((userData.spins_used || 0) >= MAX_DAILY_SPINS) {
            // no spins left
            spinButton.textContent = 'üåÄ No Spins Left';
            spinButton.className = 'button button-primary';
            spinButton.disabled = true;
            spinButton.onclick = spinWheel;
          } else {
            // Normal spin available
            spinButton.textContent = 'üåÄ Spin Now';
            spinButton.className = 'button button-primary';
            spinButton.disabled = isSpinning;
            spinButton.onclick = spinWheel;
          }
        }

        updateVIPStatus();
        maybeShowGiftBox();
      } catch(e){ console.error('updateUI err', e); }
    }

    function updateVIPStatus() {
      const vipMessage = document.getElementById('vip-message');
      if (!vipMessage) return;
      if (!userData) { vipMessage.textContent = "Loading..."; return; }
      const vip = (userData.vip_status || 'free').toString().toLowerCase();
      if (vip === "free") { vipMessage.textContent = "You're currently a Free User. Win a VIP on the wheel or upgrade in your dashboard."; }
      else if (vip === "basic") { vipMessage.textContent = "You're ü•â Basic VIP ‚Äî Spin now for a chance to upgrade to ü•à Silver!"; }
      else if (vip === "silver") { vipMessage.textContent = "You're ü•à Silver VIP ‚Äî Spin now for a chance to upgrade to ü•á Gold!"; }
      else if (vip === "gold") { vipMessage.textContent = "You're ü•á Gold VIP ‚Äî Maximum tier unlocked! Enjoy premium rewards!"; }
      else if (vip === "platinum") { vipMessage.textContent = "üíé Platinum VIP ‚Äî Exclusive rewards unlocked!"; }
      else { vipMessage.textContent = `VIP: ${vip}`; }
    }

    // ---------- gift box click handler ----------
    document.addEventListener('DOMContentLoaded', ()=> {
      const gift = document.getElementById('giftBox');
      gift && gift.addEventListener('click', async ()=> {
        try {
          // gift gives +3 spins and only once per day (we track gift_box_claimed_date)
          if (typeof show_10176108 === 'function') {
            show_10176108('pop').then(async ()=> {
              if (userData) {
                // grant 3 spins: reduce spins_used by 3 but not below 0
                userData.spins_used = Math.max(0, (userData.spins_used||0)-3);
                // mark gift claimed for today
                userData.gift_box_claimed_date = new Date().toISOString().split('T')[0];
                if (window.dataSdk && typeof window.dataSdk.update === 'function') await window.dataSdk.update(userData).catch(()=>{});
                const wrapper = { action:'giftbox_opened', payload:{ user_id: telegramUserId || null, reward_spins:3, spins_used: userData.spins_used, ts: new Date().toISOString() } };
                await postToCallbackOrWebhook(wrapper, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
                showModal("üéÅ Gift Opened!", "You received +3 spins!");
                maybeShowGiftBox();
                updateUI();
              }
            }).catch(err => { console.warn('Ad error', err); showModal("‚ö†Ô∏è Ad Error","Could not load ad. Try again later."); });
          } else {
            if (userData) {
              userData.spins_used = Math.max(0, (userData.spins_used||0)-3);
              userData.gift_box_claimed_date = new Date().toISOString().split('T')[0];
              if (window.dataSdk && typeof window.dataSdk.update === 'function') await window.dataSdk.update(userData).catch(()=>{});
              const wrapper = { action:'giftbox_opened', payload:{ user_id: telegramUserId||null, reward_spins:3, spins_used:userData.spins_used, ts:new Date().toISOString() } };
              await postToCallbackOrWebhook(wrapper, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
              showModal("üéÅ Gift Opened!", "You received +3 spins!");
              maybeShowGiftBox();
              updateUI();
            }
          }
        } catch(e) { console.error('gift click err', e); }
      });
    });

    // ---------- event listeners ----------
    function setupEventListeners() {
      const spinBtn = document.getElementById('spin-button');
      if (spinBtn && !spinBtn._gaingrid_bound) {
        spinBtn.addEventListener('click', ()=>{
          const btn = document.getElementById('spin-button');
          if (btn && typeof btn.onclick === 'function') btn.onclick();
        });
        spinBtn._gaingrid_bound = true;
      }

      const refreshBtn = document.getElementById('refresh-button');
      if (refreshBtn && !refreshBtn._gaingrid_bound) {
        refreshBtn.addEventListener('click', ()=> {
          if (isSpinning) return;
          shuffleWheel();
          renderWheel();
          showModal("üîÑ Wheel Refreshed!", "Segments have been shuffled!\nüé° Try your luck again!");
        });
        refreshBtn._gaingrid_bound = true;
      }

      const modalClose = document.getElementById('modal-close');
      if (modalClose && !modalClose._gaingrid_bound) {
        modalClose.addEventListener('click', closeModal);
        modalClose._gaingrid_bound = true;
      }
    }

    async function onConfigChange(config) {
      try {
        document.getElementById('main-title').textContent = config.main_title || defaultConfig.main_title;
        document.getElementById('subtitle').textContent = config.subtitle || defaultConfig.subtitle;
        document.getElementById('footer-text').textContent = config.footer_text || defaultConfig.footer_text;
        document.getElementById('support-links').textContent = config.support_links || defaultConfig.support_links;
      } catch(e){ console.warn('onConfigChange err', e); }
    }

    if (window.elementSdk) {
      try {
        window.elementSdk.init({
          defaultConfig,
          onConfigChange,
          mapToCapabilities: (config)=>({ recolorables:[], borderables:[], fontEditable:undefined, fontSizeable:undefined }),
          mapToEditPanelValues: (config)=> new Map([
            ["main_title", config.main_title || defaultConfig.main_title],
            ["subtitle", config.subtitle || defaultConfig.subtitle],
            ["footer_text", config.footer_text || defaultConfig.footer_text],
            ["support_links", config.support_links || defaultConfig.support_links]
          ])
        });
      } catch(e){ console.warn('elementSdk.init err', e); }
    }

    // Expose debug helpers (preserve original exposures)
    window.gaingrid = {
      getState: () => ({ userData, incomingPayload, currentSegments, stagedSpinCount, stagedResults }),
      openSmartAd,
      spinWheel,
      watchAdFlow,
      renderWheel
    };

    // Kick off
    initializeApp();

  })();
</script>

<!-- Cloudflare challenge iframe snippet (kept) -->
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'99d5ba394774a49a',t:'MTc2Mjk0NzM0Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>