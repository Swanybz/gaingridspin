<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GainGrid Spin & Win</title>

  <!-- Monetag SDK (ads) -->
  <script src='//libtl.com/sdk.js' data-zone='10176108' data-sdk='show_10176108'></script>

  <script src="/_sdk/data_sdk.js"></script>
  <script src="/_sdk/element_sdk.js"></script>

  <style>
    /* ---------- your existing styles (kept exactly as provided) ---------- */
    body { box-sizing:border-box; margin:0; padding:0; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg,#4a148c 0%,#880e4f 100%); color:#fff; min-height:100%; overflow-x:hidden; }
    *{box-sizing:border-box}
    .container{max-width:600px;margin:0 auto;padding:20px}
    .header{text-align:center;margin-bottom:30px;padding:20px}
    .header h1{font-size:32px;margin:0 0 10px 0;text-shadow:2px 2px 4px rgba(0,0,0,0.3)}
    .header p{font-size:16px;margin:0;opacity:0.9}
    .wheel-container{position:relative;width:100%;max-width:400px;margin:0 auto 30px;aspect-ratio:1;perspective:1200px}
    .wheel{width:100%;height:100%;border-radius:50%;position:relative;box-shadow:0 12px 50px rgba(0,0,0,0.55), 0 0 60px rgba(0,0,0,0.2) inset;transition:transform 4s cubic-bezier(0.17,0.67,0.12,0.99);border:12px solid rgba(255,215,0,0.15);transform-style:preserve-3d;background:linear-gradient(145deg, rgba(255,255,255,0.03), rgba(0,0,0,0.12))}
    .wheel-segment{position:absolute;width:50%;height:50%;transform-origin:100% 100%;clip-path:polygon(0 0,100% 0,100% 100%);display:flex;align-items:flex-start;justify-content:center;font-size:11px;font-weight:bold;text-align:center;padding:15px 5px 5px 5px;overflow:hidden;backface-visibility:hidden}
    .segment-text{transform:rotate(-90deg) translateX(-20px);white-space:nowrap;text-shadow:1px 1px 2px rgba(0,0,0,0.5)}
    .wheel-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) translateZ(60px);width:80px;height:80px;background:linear-gradient(135deg,#ffd700,#ffed4e);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:24px;box-shadow:0 10px 40px rgba(0,0,0,0.45), inset 0 6px 18px rgba(255,255,255,0.25);z-index:50}
    .wheel-pointer{position:absolute;top:-20px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:20px solid transparent;border-right:20px solid transparent;border-top:40px solid #ec407a;z-index:60;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.3))}
    .vip-status{background:rgba(255,255,255,0.06);border-radius:15px;padding:20px;margin-bottom:25px;text-align:center;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.06)}
    .vip-status h3{margin:0 0 10px 0;font-size:20px;color:#ffd700}
    .vip-status p{margin:0;font-size:14px;line-height:1.5}
    .controls{background:rgba(255,255,255,0.06);border-radius:15px;padding:25px;margin-bottom:25px;backdrop-filter:blur(10px);border:2px solid rgba(255,255,255,0.06)}
    .progress-bar{margin-bottom:20px}
    .progress-label{display:flex;justify-content:space-between;margin-bottom:8px;font-size:14px;font-weight:bold}
    .progress-track{width:100%;height:12px;background:rgba(0,0,0,0.25);border-radius:6px;overflow:hidden}
    .progress-fill{height:100%;background:linear-gradient(90deg,#00e5ff,#ffd700);border-radius:6px;transition:width 0.3s ease}
    .button{width:100%;padding:16px;margin-bottom:12px;border:none;border-radius:12px;font-size:16px;font-weight:bold;cursor:pointer;transition:all 0.3s ease;box-shadow:0 6px 25px rgba(0,0,0,0.4)}
    .button:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 8px 30px rgba(0,0,0,0.45)}
    .button:active:not(:disabled){transform:translateY(0)}
    .button:disabled{opacity:0.5;cursor:not-allowed}
    .button-primary{background:linear-gradient(135deg,#8e24aa,#ab47bc);color:white}
    .button-secondary{background:linear-gradient(135deg,#ec407a,#f06292);color:white}
    .button-tertiary{background:rgba(255,255,255,0.12);color:white;border:2px solid rgba(255,255,255,0.12)}
    .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;align-items:center;justify-content:center;padding:20px}
    .modal.active{display:flex}
    .modal-content{background:linear-gradient(135deg,#4a148c,#880e4f);border-radius:20px;padding:40px;max-width:400px;width:100%;text-align:center;box-shadow:0 10px 40px rgba(0,0,0,0.5);border:3px solid #ffd700;animation:modalPop 0.3s ease}
    @keyframes modalPop{0%{transform:scale(0.8);opacity:0}100%{transform:scale(1);opacity:1}}
    .modal-content h2{font-size:28px;margin:0 0 15px 0;color:#ffd700}
    .modal-content p{font-size:18px;margin:0 0 25px 0;line-height:1.5}
    .footer{text-align:center;padding:30px 20px;margin-top:40px;border-top:2px solid rgba(255,255,255,0.08)}
    .footer p{margin:5px 0;font-size:14px;opacity:0.8}
    .loading{display:inline-block;width:20px;height:20px;border:3px solid rgba(255,255,255,0.3);border-top-color:white;border-radius:50%;animation:spin 0.8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Flying gift box */
    .gift-box{position:fixed;width:70px;height:70px;right:12%;top:18%;z-index:120;border-radius:10px;display:none;align-items:center;justify-content:center;cursor:pointer;transform-style:preserve-3d;perspective:1000px}
    .gift-inner{width:100%;height:100%;border-radius:10px;background:linear-gradient(135deg,#fff,#ffd3ff);color:#4a148c;display:flex;align-items:center;justify-content:center;font-weight:800;box-shadow:0 10px 30px rgba(0,0,0,0.45);transform-origin:center}
    .gift-3d{animation:flyAround 14s linear infinite, floatY 3s ease-in-out infinite;transform-style:preserve-3d}
    @keyframes floatY{0%{transform:translateZ(0) translateY(0) rotateX(0) rotateY(0)}50%{transform:translateZ(12px) translateY(-6px) rotateX(6deg) rotateY(3deg)}100%{transform:translateZ(0) translateY(0) rotateX(0) rotateY(0)}}
    @keyframes flyAround{0%{right:10%;top:10%;transform:translateZ(0) rotateY(0)}25%{right:60%;top:12%;transform:translateZ(18px) rotateY(30deg)}50%{right:55%;top:65%;transform:translateZ(6px) rotateY(60deg)}75%{right:12%;top:62%;transform:translateZ(18px) rotateY(90deg)}100%{right:10%;top:10%;transform:translateZ(0) rotateY(0)}}

    /* Ad overlay (cancelable) */
    .ad-overlay { position: fixed; inset:0; background: rgba(0,0,0,0.6); z-index:2000; display:flex; align-items:center; justify-content:center; }
    .ad-container { position: relative; width: min(900px, 96%); height: min(600px, 86%); background:#000; border-radius:10px; overflow:hidden; box-shadow:0 20px 60px rgba(0,0,0,0.6); }
    .ad-close { position:absolute; top:10px; right:10px; z-index:2010; background: rgba(255,255,255,0.15); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .ad-iframe { width:100%; height:100%; border: none; display:block; }

    @media (max-width:480px){.header h1{font-size:24px}.header p{font-size:14px}.wheel-container{max-width:300px}.wheel-segment{font-size:9px;padding:12px 3px 3px 3px}.segment-text{transform:rotate(-90deg) translateX(-15px)}.modal-content{padding:30px 20px}.modal-content h2{font-size:24px}.modal-content p{font-size:16px}.gift-box{width:58px;height:58px}}
  </style>

  <style>@view-transition { navigation: auto; }</style>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1 id="main-title">üé° Spin &amp; Win G-Coins!</h1>
      <p id="subtitle">Unlock rewards, rare VIPs, and bonuses. Spin 10x daily!</p>
    </div>

    <div class="wheel-container">
      <div class="wheel-pointer"></div>
      <div class="wheel" id="wheel"></div>
      <div class="wheel-center">üé°</div>
    </div>

    <div class="vip-status" id="vip-status">
      <h3>VIP Status</h3>
      <p id="vip-message">Loading...</p>
    </div>

    <div class="controls">
      <div class="progress-bar">
        <div class="progress-label"><span>Daily Spins</span> <span id="spins-count">0/10</span></div>
        <div class="progress-track"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
      </div>
      <button class="button button-primary" id="spin-button"> üåÄ Spin Now </button>
      <button class="button button-tertiary" id="refresh-button"> üîÑ Refresh Wheel </button>
    </div>
  </div>

  <!-- Flying gift box -->
  <div class="gift-box" id="giftBox" title="Lucky Gift ‚Äî click to open">
    <div class="gift-inner gift-3d" id="giftInner">üéÅ</div>
  </div>

  <div class="footer">
    <p id="footer-text">¬© GainGrid 2025 | All rights reserved</p>
    <p id="support-links">Telegram Support | Privacy Policy</p>
  </div>

  <div class="modal" id="result-modal">
    <div class="modal-content">
      <h2 id="modal-title">üéâ Congratulations!</h2>
      <p id="modal-message">You won something amazing!</p>
      <button class="button button-primary" id="modal-close">Continue</button>
    </div>
  </div>

  <!-- ad overlay (created dynamically when needed) -->

  <script>
  (function () {
    // ---------- preserved config & rewards ----------
    const defaultConfig = {
      main_title: "üé° Spin & Win G-Coins!",
      subtitle: "Unlock rewards, rare VIPs, and bonuses. Spin 10x daily!",
      footer_text: "¬© GainGrid 2025 | All rights reserved",
      support_links: "Telegram Support | Privacy Policy"
    };

    const wheelSegmentsBase = [
      { key: '50', text: "+50 G-Coins", color: "#8e24aa", value: 50, type: "coins" },
      { key: '100', text: "+100 G-Coins", color: "#ab47bc", value: 100, type: "coins" },
      { key: '200', text: "+200 G-Coins", color: "#ba68c8", value: 200, type: "coins" },
      { key: 'myst', text: "üéÅ Mystery Box", color: "#ce93d8", value: 0, type: "mystery" },
      { key: 'vip_basic', text: "ü•â Basic VIP", color: "#ffd700", value: 0, type: "vip_basic" },
      { key: 'try', text: "Try Again", color: "#ec407a", value: 0, type: "nothing" },
      { key: 'dbl', text: "üîÅ Spin x2", color: "#f06292", value: 0, type: "double_spin" },
      { key: 'mult', text: "üî• Bonus x2", color: "#f48fb1", value: 0, type: "multiplier" },
      { key: 'cd', text: "üßä Cooldown Cut", color: "#00e5ff", value: 0, type: "cooldown" },
      { key: '500', text: "+500 G-Coins", color: "#9c27b0", value: 500, type: "coins" }
    ];

    // ---------- state ----------
    let currentSegments = [];
    let userData = null;             // persisted via dataSdk or seeded from deeplink
    let isSpinning = false;
    let telegramUserId = null;
    let incomingPayload = null;
    let autoStartRequested = false;
    let lastAdCloseAt = 0;
    const AD_COOLDOWN_MS = 5000; // 5s between popunders
    const VIP_ELIGIBLE_DAYS = 3; // show VIP segment only after this many days

    // ---------- utilities ----------
    function safeText(resp){ try { return resp ? resp.text() : null; } catch(e) { return null; } }

    // Try to decode base64 or JSON safely (kept and hardened)
    function tryParseJSONorB64(input) {
      if (!input) return null;
      let s = String(input).trim();
      // JSON raw
      if ((s.startsWith('{') && s.endsWith('}')) || (s.startsWith('[') && s.endsWith(']'))) {
        try { return JSON.parse(s); } catch(e) {}
      }
      // URL-decoded JSON
      try {
        const dec = decodeURIComponent(s);
        if ((dec.startsWith('{') && dec.endsWith('}')) || (dec.startsWith('[') && dec.endsWith(']'))) {
          return JSON.parse(dec);
        }
      } catch(e){}
      // base64 (URL-safe accounted)
      try {
        let b = s.replace(/-/g,'+').replace(/_/g,'/');
        b = b + '='.repeat((4 - (b.length % 4)) % 4);
        let raw = atob(b);
        try { raw = decodeURIComponent(escape(raw)); } catch(e){}
        if ((raw.startsWith('{') && raw.endsWith('}')) || (raw.startsWith('[') && raw.endsWith(']'))) {
          return JSON.parse(raw);
        } else {
          return raw;
        }
      } catch(e){}
      return null;
    }

    function parseDeeplinkPayload() {
      try {
        const qs = new URLSearchParams(location.search || '');
        const candidates = [];
        ['start','data','s','p','payload'].forEach(k => { if (qs.get(k)) candidates.push(qs.get(k)); });
        if (location.hash) {
          let rawHash = location.hash.replace(/^#/,'');
          let hashQs = rawHash.split('?').slice(1).join('?');
          if (hashQs) {
            const hparams = new URLSearchParams(hashQs);
            ['data','start','s','p','payload'].forEach(k => { if (hparams.get(k)) candidates.push(hparams.get(k)); });
          } else {
            candidates.push(rawHash);
          }
        }
        if (location.search && location.search.length>1) {
          const raw = location.search.replace(/^\?/,'');
          candidates.push(raw);
        }
        for (const c of candidates) {
          const parsed = tryParseJSONorB64(c);
          if (parsed && typeof parsed === 'object') return parsed;
        }
        return null;
      } catch (e) {
        console.warn('parseDeeplinkPayload err', e);
        return null;
      }
    }

    // prefer webhook from incoming payload when posting to bot
    async function postToCallbackOrWebhook(wrapper, callbackUrlCandidate) {
      try {
        const candidate = callbackUrlCandidate || (incomingPayload && (incomingPayload.callback_url || incomingPayload.callbackUrl || incomingPayload.webhook || incomingPayload.callbackurl)) || '<% options.url %>';
        if (!candidate) { console.warn('No webhook/callback url to post to.'); return { ok:false, error:'no_target' }; }
        const resp = await fetch(candidate, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(wrapper),
          keepalive: true
        });
        return { ok: resp && resp.ok, status: resp && resp.status, text: await safeText(resp) };
      } catch (e) {
        console.error('postToCallbackOrWebhook err', e);
        return { ok:false, error:String(e) };
      }
    }

    async function postToBotWebhook(wrapper) {
      return postToCallbackOrWebhook(wrapper, null);
    }

    // ---------- VIP eligibility ----------
    function vipEligibleToShow(user) {
      // If user has vip_first_seen_time stored ‚Äî only show after VIP_ELIGIBLE_DAYS days
      try {
        const t = user.vip_first_seen_time;
        if (!t) {
          // seed timestamp but do not show yet
          user.vip_first_seen_time = new Date().toISOString();
          // persist asynchronously if dataSdk available
          if (window.dataSdk && user && user.id) {
            window.dataSdk.update(user).catch(()=>{});
          }
          return false;
        } else {
          const diff = Date.now() - new Date(t).getTime();
          const days = diff / (1000*60*60*24);
          return days >= VIP_ELIGIBLE_DAYS;
        }
      } catch(e){ return false; }
    }

    function buildSegmentsForUser(user) {
      // Always start with base
      const segs = [...wheelSegmentsBase];
      // Add VIP segment only if eligible AND not currently a high-tier already
      if (user && user.vip_status && user.vip_status !== 'free' && vipEligibleToShow(user)) {
        // push a higher-tier visual segment (rare)
        segs.splice( Math.max(1, Math.floor(segs.length/2)), 0, { key:'vip_shiny', text: 'üíé VIP RARE', color:'#ffd700', value:0, type:'vip_shiny' } );
      }
      return segs;
    }

    // ---------- UI rendering ----------
    function shuffleWheel() {
      currentSegments = buildSegmentsForUser(userData).sort(() => Math.random() - 0.5);
    }

    function renderWheel() {
      const wheel = document.getElementById('wheel');
      wheel.innerHTML = '';
      const segmentAngle = 360 / currentSegments.length;
      currentSegments.forEach((segment, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'wheel-segment';
        segmentDiv.style.background = segment.color;
        // maintain in-board labels (skew so they appear inside)
        segmentDiv.style.transform = `rotate(${index * segmentAngle}deg) skewY(${-(90 - segmentAngle)}deg) translateZ(0)`;
        const textSpan = document.createElement('span');
        textSpan.className = 'segment-text';
        textSpan.textContent = segment.text;
        segmentDiv.appendChild(textSpan);
        wheel.appendChild(segmentDiv);
      });
    }

    // ---------- gift box logic ----------
    function maybeShowGiftBox() {
      const gift = document.getElementById('giftBox');
      if (!userData) { gift.style.display = 'none'; return; }
      const spinsUsed = userData.spins_used || 0;
      // show only at exactly 9 used (i.e., user has 1 spin left until 10)
      if (spinsUsed === 9) gift.style.display = 'flex'; else gift.style.display = 'none';
    }

    // ---------- modal helpers ----------
    function showModal(title, message) { document.getElementById('modal-title').textContent = title; document.getElementById('modal-message').textContent = message; document.getElementById('result-modal').classList.add('active'); }
    function closeModal() { document.getElementById('result-modal').classList.remove('active'); }

    // ---------- deeplink + auto-validation (preserve ads_validate flow) ----------
    function startAutoValidationFlow(payload) {
      // kept similar to your previous logic but we DO NOT auto-start spin unless payload.start === true
      try {
        if (!payload) return;
        incomingPayload = payload;
        // if payload.secs exists and >0 we treat as "ad timer" (ads_validate flow)
        const secs = Number(payload.secs || payload.seconds || payload.duration || 0);
        const adId = payload.ad_id || payload.adid || payload.id;
        const userId = payload.user_id || (payload.user && payload.user.user_id) || payload.userid || payload.userId;

        // store incoming globally
        window.__gaingrid_incoming = payload;

        if (secs > 0) {
          const vipMessageEl = document.getElementById('vip-message');
          if (vipMessageEl) vipMessageEl.textContent = `Ad playing... (${secs}s) ‚Äî page will auto-validate when done.`;
          let remaining = secs;
          const interval = setInterval(()=> {
            remaining--;
            if (vipMessageEl) vipMessageEl.textContent = `Ad playing... (${remaining}s) ‚Äî page will auto-validate when done.`;
            if (remaining <= 0) { clearInterval(interval); }
          }, 1000);

          setTimeout(async ()=> {
            const wrapper = {
              action: 'ads_validate',
              payload: {
                ad_id: adId,
                user_id: userId,
                status: 'ad_complete',
                secs: secs,
                reward: payload.reward || payload.rewards || payload.amount || null,
                ts: new Date().toISOString()
              },
              meta: { from_hosted: true, auto: true }
            };
            const res = await postToCallbackOrWebhook(wrapper, payload.callback_url || payload.webhook);
            console.log('auto validation POST result', res);
            try { const vipEl = document.getElementById('vip-message'); if (vipEl) vipEl.textContent = 'Ad validated ‚Äî thank you!'; } catch(e){}
            if (res && res.ok) {
              showModal('‚úÖ Ad Verified','Thanks ‚Äî reward will be credited shortly.');
              setTimeout(()=> { closeModal(); try { if (window.Telegram && Telegram.WebApp) Telegram.WebApp.close(); } catch(e){} }, 1400);
            } else {
              showModal('‚ö†Ô∏è Validation Failed','Could not notify bot. Please try again or contact support.');
            }
          }, secs*1000 + 300);
        } else {
          // non-ad payloads (we still keep incoming for spin callback)
          // If payload.start === true => request auto-start of spin.
          if (payload.start === true || payload.start === 'true') {
            autoStartRequested = true;
            // we will auto-start after initialization
          }
        }

        setupSkipOnClose(payload);
      } catch (e) { console.error('startAutoValidationFlow err', e); }
    }

    function setupSkipOnClose(payload) {
      let alreadySent = false;
      const callback = payload.callback_url || payload.callbackUrl || payload.webhook || payload.callbackurl;
      function handler(e) {
        try {
          if (alreadySent) return;
          alreadySent = true;
          const adId = payload.ad_id || payload.adid || payload.id;
          const userId = payload.user_id || (payload.user && payload.user.user_id) || payload.userid || payload.userId;
          const wrapper = { action:'ads_validate', payload: { ad_id:adId, user_id:userId, status:'ad_skipped', ts:new Date().toISOString() }, meta:{ from_hosted:true, reason:'closed' } };
          try {
            const target = callback || (incomingPayload && (incomingPayload.callback_url||incomingPayload.webhook)) || '<% options.url %>';
            const blob = new Blob([JSON.stringify(wrapper)], { type: 'application/json' });
            if (navigator && navigator.sendBeacon) { navigator.sendBeacon(target, blob); }
            else { fetch(target, { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(wrapper), keepalive:true }); }
          } catch (err) { console.warn('skip-on-close post failed', err); }
        } catch(e){}
      }
      window.addEventListener('beforeunload', handler);
      window.addEventListener('pagehide', handler);
    }

    // ---------- dataSdk & initialization ----------
    const dataHandler = {
      onDataChanged(data) {
        if (data && data.length > 0) {
          userData = data[0];
          // ensure data fields exist
          userData.spins_used = userData.spins_used || 0;
          userData.total_coins_won = userData.total_coins_won || 0;
          userData.vip_status = userData.vip_status || 'free';
          checkDailyReset();
          shuffleWheel();
          renderWheel();
          updateUI();
          maybeShowGiftBox();
        }
      }
    };

    function getTelegramUserIdFromWebApp() {
      try {
        if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initDataUnsafe && Telegram.WebApp.initDataUnsafe.user) {
          return Telegram.WebApp.initDataUnsafe.user.id;
        }
      } catch(e){}
      return null;
    }

    async function initializeApp() {
      // parse deeplink payload first (so incomingPayload seeded)
      const incoming = parseDeeplinkPayload();
      if (incoming) {
        console.log('Deeplink payload detected:', incoming);
        // save for postbacks + later uses
        incomingPayload = incoming;
        // seed some UI state
        if (incoming.vip_level || incoming.vipLevel) {
          if (!userData) userData = {};
          // do not overwrite longer VIPs
          if (!userData.vip_status || userData.vip_status === 'free') userData.vip_status = (incoming.vip_level || incoming.vipLevel).toString().toLowerCase();
        }
        if (incoming.user_id || incoming.userid || (incoming.user && incoming.user.user_id)) {
          telegramUserId = incoming.user_id || incoming.userid || (incoming.user && incoming.user.user_id) || telegramUserId;
        }
        // If payload requests auto-start
        if (incoming.start === true || incoming.start === 'true') autoStartRequested = true;
        // If the incoming contains "start_immediately": true, also set autoStart
        if (incoming.start_immediately === true) autoStartRequested = true;

        // Start ads_validate flow if secs present
        startAutoValidationFlow(incoming);
      }

      // Initialize data SDK
      const initResult = await window.dataSdk.init(dataHandler).catch(()=>({isOk:false}));
      if (!initResult || !initResult.isOk) {
        console.warn("dataSdk failed ‚Äî using in-page fallback state");
        // fallback simple local userData for UI to function
        const today = new Date().toISOString().split('T')[0];
        userData = userData || { id:"user_spin_fallback", spins_used:0, last_reset_date:today, total_coins_won:0, vip_status:"free", vip_expiry:"", vip_first_seen_time: null };
        // render
        shuffleWheel();
        renderWheel();
        setupEventListeners();
        updateUI();
        maybeShowGiftBox();
        // If autoStart was requested, only auto-start if explicit
        if (autoStartRequested) {
          // don't spin automatically if spins used >= 10
          if ((userData.spins_used || 0) < 10) {
            // kick off a short delay so UI paint finishes
            setTimeout(()=>{ spinWheel(); }, 600);
          }
        }
        return;
      }

      // If init OK but no userData created yet, create default
      if (!userData) {
        const today = new Date().toISOString().split('T')[0];
        const createResult = await window.dataSdk.create({ id: "user_spin_data", spins_used:0, last_reset_date:today, total_coins_won:0, vip_status:"free", vip_expiry:"", vip_first_seen_time: null });
        if (createResult && createResult.isOk) userData = createResult.data;
      }

      // Render UI after data present
      shuffleWheel();
      renderWheel();
      setupEventListeners();
      updateUI();
      maybeShowGiftBox();

      // If deeplink asked to auto-start, start a spin (if spins left)
      if (autoStartRequested && userData && (userData.spins_used || 0) < 10) {
        setTimeout(()=>{ spinWheel(); }, 600);
      }
    }

    // ---------- check/reset ----------
    function checkDailyReset() {
      if (!userData) return;
      const today = new Date().toISOString().split('T')[0];
      if (userData.last_reset_date !== today) {
        userData.spins_used = 0;
        userData.last_reset_date = today;
        window.dataSdk.update(userData).catch(()=>{});
      }
    }

    // ---------- process win + webhook posting ----------
    async function processWin(segment) {
      if (!userData) return;
      userData.spins_used = (userData.spins_used || 0) + 1;

      const resultPayload = {
        action: 'spin_result',
        payload: {
          user_id: telegramUserId || (userData && (userData.telegram_id || userData.id)) || null,
          segment_type: segment.type,
          value: segment.value || 0,
          text: segment.text,
          spins_used: userData.spins_used,
          ts: new Date().toISOString()
        },
        meta: { from_frontend: true }
      };

      let modalTitle = "üéâ Congratulations!";
      let modalMessage = "";

      switch(segment.type) {
        case "coins":
          userData.total_coins_won = (userData.total_coins_won || 0) + (segment.value || 0);
          modalTitle = "üí∞ You Won!";
          modalMessage = `You won +${segment.value} G-Coins!\n‚úÖ Credited to your wallet`;
          break;
        case "vip_basic":
          userData.vip_status = "basic";
          const expiryDate = new Date(); expiryDate.setDate(expiryDate.getDate() + 7);
          userData.vip_expiry = expiryDate.toISOString();
          modalTitle = "üëë VIP Unlocked!";
          modalMessage = "You won ü•â Basic VIP (7-day access)\n‚úÖ Activated now!";
          break;
        case "vip_shiny":
          // Rare VIP (hard-to-get) - make it robustly rare by only showing in segments when eligible
          userData.vip_status = "platinum";
          const exp = new Date(); exp.setDate(exp.getDate() + 14);
          userData.vip_expiry = exp.toISOString();
          modalTitle = "üíé Legendary VIP!";
          modalMessage = "You won a rare VIP! üéâ 14-day access granted.";
          break;
        case "mystery":
          const mysteryCoins = Math.floor(Math.random() * 300) + 100;
          userData.total_coins_won = (userData.total_coins_won || 0) + mysteryCoins;
          modalTitle = "üéÅ Mystery Box!";
          modalMessage = `You found +${mysteryCoins} G-Coins inside!\n‚úÖ Credited to your wallet`;
          resultPayload.payload.value = mysteryCoins;
          break;
        case "double_spin":
          userData.spins_used = Math.max(0, userData.spins_used - 1);
          modalTitle = "üîÅ Bonus Spin!";
          modalMessage = "You won an extra spin!\n‚úÖ Spin again now!";
          break;
        case "multiplier":
          userData.next_multiplier = (userData.next_multiplier || 1) * 2;
          modalTitle = "üî• Multiplier Active!";
          modalMessage = "Your next coin win will be doubled!\n‚úÖ Spin again to activate!";
          break;
        case "cooldown":
          userData.cooldown_cut = true;
          modalTitle = "üßä Cooldown Cut!";
          modalMessage = "Spin cooldown reduced!\n‚úÖ Spin faster now!";
          break;
        case "nothing":
        default:
          modalTitle = "üòÖ Try Again!";
          modalMessage = "Better luck next time!\nüé° Keep spinning for rewards!";
          break;
      }

      // update saved state
      const updateResult = await window.dataSdk.update(userData).catch(e => ({ isOk:false }));
      if (!updateResult || !updateResult.isOk) console.error("Failed to update user data in dataSdk");

      // post to bot webhook/callback
      try {
        const wbRes = await postToBotWebhook(resultPayload);
        console.log('Webhook post result:', wbRes);
      } catch(e) { console.warn('Webhook err', e); }

      showModal(modalTitle, modalMessage);
      maybeShowGiftBox();

      // If user completed daily spins, send final summary
      if ((userData.spins_used || 0) >= 10) {
        const finalWrapper = {
          action: 'daily_spin_complete',
          payload: {
            user_id: telegramUserId || (userData && (userData.telegram_id || userData.id)) || null,
            vip_status: userData.vip_status || 'free',
            spins_used: userData.spins_used || 10,
            total_coins_won: userData.total_coins_won || 0,
            ts: new Date().toISOString()
          },
          meta: { from_frontend: true }
        };
        try { await postToBotWebhook(finalWrapper); } catch(e){ console.warn('final post err', e); }
      }
    }

    // ---------- spin implementation ----------
    async function spinWheel() {
      if (isSpinning || !userData || (userData.spins_used >= 10)) return;
      isSpinning = true;
      const spinButton = document.getElementById('spin-button');
      spinButton.disabled = true;
      spinButton.innerHTML = '<span class="loading"></span>';

      const wheel = document.getElementById('wheel');
      const segmentAngle = 360 / currentSegments.length;
      // pick result fairly
      const randomIndex = Math.floor(Math.random() * currentSegments.length);
      const targetRotation = 360 * 5 + (randomIndex * segmentAngle) + (segmentAngle / 2);

      wheel.style.transition = 'transform 4s cubic-bezier(0.17,0.67,0.12,0.99)';
      wheel.style.transform = `rotate(${targetRotation}deg) translateZ(0)`;

      setTimeout(async () => {
        const winningSegment = currentSegments[randomIndex];
        await processWin(winningSegment);

        // reset transform visually (without flicker)
        wheel.style.transition = 'none';
        wheel.style.transform = 'rotate(0deg)';
        setTimeout(()=>{ wheel.style.transition = 'transform 4s cubic-bezier(0.17,0.67,0.12,0.99)'; },50);

        isSpinning = false;
        spinButton.innerHTML = 'üåÄ Spin Now';
        updateUI();
      }, 4000);
    }

    // ---------- watchAd flow (watch ad to unlock spin) ----------
    async function watchAdFlow() {
      try {
        showModal("üì∫ Watching Ad...", "Please wait while the ad plays...\n‚è≥ This will take a few seconds");
        // prefer provider SDK if available
        if (typeof show_10176108 === 'function') {
          // use the popup rewarded
          await show_10176108('pop');
          // reward user: reduce spins_used (i.e., add a spin) only if they had no spins
          if (userData) {
            userData.spins_used = Math.max(0, (userData.spins_used || 0) - 1);
            await window.dataSdk.update(userData).catch(()=>{});
            // post ad_reward to backend
            const wrapper = { action:'ad_reward', payload:{ user_id: telegramUserId||null, reward_spins:1, spins_used:userData.spins_used, ts:new Date().toISOString() }, meta:{from_frontend:true} };
            await postToCallbackOrWebhook(wrapper, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
            closeModal();
            showModal("‚úÖ Spin Unlocked!", "Ad watched successfully!\nüé° You earned 1 free spin!");
            setTimeout(()=>{ closeModal(); updateUI(); }, 1600);
            return;
          }
        } else {
          // fallback: simulate ad watched
          await new Promise(res => setTimeout(res, 2000));
          if (userData) {
            userData.spins_used = Math.max(0, (userData.spins_used || 0) - 1);
            await window.dataSdk.update(userData).catch(()=>{});
            await postToCallbackOrWebhook({ action:'ad_reward', payload:{ user_id:telegramUserId||null, reward_spins:1, ts:new Date().toISOString() } }, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
            closeModal();
            showModal("‚úÖ Spin Unlocked!", "Ad simulated: you earned 1 free spin!");
            setTimeout(()=>{ closeModal(); updateUI(); }, 1200);
            return;
          }
        }
      } catch(e) {
        console.error('watchAd error', e);
        closeModal();
        showModal("‚ö†Ô∏è Ad Error","Could not show ad. Try again later.");
      }
    }

    // ---------- smartlink popunder (cancelable iframe) ----------
    // Uses the smartlinks you supplied. When closed, waits AD_COOLDOWN_MS before allowing next ad.
    function openSmartAd(url) {
      // respect cooldown
      if (Date.now() - lastAdCloseAt < AD_COOLDOWN_MS) return;
      const overlay = document.createElement('div');
      overlay.className = 'ad-overlay';
      overlay.id = 'adOverlay';

      const container = document.createElement('div');
      container.className = 'ad-container';

      const closeBtn = document.createElement('button');
      closeBtn.className = 'ad-close';
      closeBtn.textContent = 'Close';

      const iframe = document.createElement('iframe');
      iframe.className = 'ad-iframe';
      iframe.src = url;

      closeBtn.addEventListener('click', () => {
        // remove overlay and set cooldown
        document.body.removeChild(overlay);
        lastAdCloseAt = Date.now();
        // allow next ad after AD_COOLDOWN_MS (already enforced by timestamp)
      });

      container.appendChild(closeBtn);
      container.appendChild(iframe);
      overlay.appendChild(container);
      document.body.appendChild(overlay);
    }

    // helper to schedule popunders (non-blocking)
    function scheduleSmartlinksLoad() {
      // first after 15s (non-blocking)
      setTimeout(() => {
        // open first smartlink in non-blocking popunder but only if user interacts or we allow
        // For UX we only preload them in hidden iframes to avoid popups on mobile
        const iframe1 = document.createElement('iframe');
        iframe1.style.display = 'none';
        iframe1.src = 'https://otieu.com/4/10176185';
        document.body.appendChild(iframe1);

        // schedule the optional second
        setTimeout(()=> {
          const iframe2 = document.createElement('iframe');
          iframe2.style.display = 'none';
          iframe2.src = 'https://otieu.com/4/10176155';
          document.body.appendChild(iframe2);
        }, 5000);
      }, 15000);
    }

    // ---------- UI update ----------
    function updateUI() {
      if (!userData) return;
      const spinsLeft = Math.max(0, 10 - (userData.spins_used || 0));
      document.getElementById('spins-count').textContent = `${spinsLeft}/10`;
      const progressPercent = ((userData.spins_used || 0) / 10) * 100;
      document.getElementById('progress-fill').style.width = `${progressPercent}%`;

      const spinButton = document.getElementById('spin-button');
      // dynamic button: if user used >=2 and no spins left, show watch ad
      if ((userData.spins_used || 0) >= 2 && spinsLeft === 0) {
        spinButton.textContent = '‚ñ∂Ô∏è Watch Ad to Unlock Spin';
        spinButton.className = 'button button-secondary';
        spinButton.disabled = isSpinning;
        spinButton.onclick = watchAdFlow;
      } else if (spinsLeft === 0) {
        spinButton.textContent = 'üåÄ No Spins Left';
        spinButton.className = 'button button-primary';
        spinButton.disabled = true;
        spinButton.onclick = spinWheel;
      } else {
        spinButton.textContent = 'üåÄ Spin Now';
        spinButton.className = 'button button-primary';
        spinButton.disabled = isSpinning;
        spinButton.onclick = async () => {
          // If user must watch an ad pre-spin (your rules can be inserted here)
          // For default: just spin
          spinWheel();
        };
      }

      updateVIPStatus();
      maybeShowGiftBox();
    }

    function updateVIPStatus() {
      const vipMessage = document.getElementById('vip-message');
      if (!userData) { vipMessage.textContent = "Loading..."; return; }
      const vip = (userData.vip_status || 'free').toLowerCase();
      if (vip === "free") { vipMessage.textContent = "You're currently a Free User. Win a VIP on the wheel or upgrade in your dashboard."; }
      else if (vip === "basic") { vipMessage.textContent = "You're ü•â Basic VIP ‚Äî Spin now for a chance to upgrade to ü•à Silver!"; }
      else if (vip === "silver") { vipMessage.textContent = "You're ü•à Silver VIP ‚Äî Spin now for a chance to upgrade to ü•á Gold!"; }
      else if (vip === "gold") { vipMessage.textContent = "You're ü•á Gold VIP ‚Äî Maximum tier unlocked! Enjoy premium rewards!"; }
      else if (vip === "platinum") { vipMessage.textContent = "üíé Platinum VIP ‚Äî Exclusive rewards unlocked!"; }
    }

    // ---------- gift box click handler ----------
    document.addEventListener('DOMContentLoaded', ()=> {
      const gift = document.getElementById('giftBox');
      gift && gift.addEventListener('click', async ()=> {
        try {
          // If ad SDK exists, show reward pop then grant +3 spins. Else simulate grant.
          if (typeof show_10176108 === 'function') {
            // Use rewarded popup
            show_10176108('pop').then(async ()=> {
              if (userData) {
                userData.spins_used = Math.max(0, (userData.spins_used||0) - 3);
                await window.dataSdk.update(userData).catch(()=>{});
                const wrapper = { action:'giftbox_opened', payload:{ user_id: telegramUserId || null, reward_spins:3, spins_used: userData.spins_used, ts: new Date().toISOString() } };
                await postToCallbackOrWebhook(wrapper, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
                showModal("üéÅ Gift Opened!", "You received +3 spins!");
                maybeShowGiftBox();
                updateUI();
              }
            }).catch(err => { console.warn('Ad error', err); showModal("‚ö†Ô∏è Ad Error","Could not load ad. Try again later."); });
          } else {
            // fallback
            if (userData) {
              userData.spins_used = Math.max(0, (userData.spins_used||0) - 3);
              await window.dataSdk.update(userData).catch(()=>{});
              const wrapper = { action:'giftbox_opened', payload:{ user_id: telegramUserId||null, reward_spins:3, spins_used:userData.spins_used, ts:new Date().toISOString() } };
              await postToCallbackOrWebhook(wrapper, incomingPayload && (incomingPayload.callback_url || incomingPayload.webhook));
              showModal("üéÅ Gift Opened!", "You received +3 spins!");
              maybeShowGiftBox();
              updateUI();
            }
          }
        } catch(e) { console.error('gift click err', e); }
      });
    });

    // ---------- refresh & event listeners ----------
    function setupEventListeners() {
      document.getElementById('spin-button').addEventListener('click', () => {
        // use the assigned onclick (updateUI sets it)
        const btn = document.getElementById('spin-button');
        if (btn && typeof btn.onclick === 'function') btn.onclick();
      });
      document.getElementById('refresh-button').addEventListener('click', ()=> {
        if (isSpinning) return;
        shuffleWheel();
        renderWheel();
        showModal("üîÑ Wheel Refreshed!", "Segments have been shuffled!\nüé° Try your luck again!");
      });
      document.getElementById('modal-close').addEventListener('click', closeModal);
    }

    // ---------- elementSdk integration (kept) ----------
    async function onConfigChange(config) {
      document.getElementById('main-title').textContent = config.main_title || defaultConfig.main_title;
      document.getElementById('subtitle').textContent = config.subtitle || defaultConfig.subtitle;
      document.getElementById('footer-text').textContent = config.footer_text || defaultConfig.footer_text;
      document.getElementById('support-links').textContent = config.support_links || defaultConfig.support_links;
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config)=>({ recolorables:[], borderables:[], fontEditable:undefined, fontSizeable:undefined }),
        mapToEditPanelValues: (config)=> new Map([
          ["main_title", config.main_title || defaultConfig.main_title],
          ["subtitle", config.subtitle || defaultConfig.subtitle],
          ["footer_text", config.footer_text || defaultConfig.footer_text],
          ["support_links", config.support_links || defaultConfig.support_links]
        ])
      });
    }

    // ---------- kick off ----------
    initializeApp();

    // preload smartlinks behind the scenes after some seconds
    scheduleSmartlinksLoad();

    // expose some helpers for debugging (optional)
    window.gaingrid = {
      getState: () => ({ userData, incomingPayload, currentSegments }),
      openSmartAd,
      spinWheel,
      watchAdFlow,
      renderWheel
    };

  })();
  </script>

  <!-- Cloudflare challenge iframe snippet (kept) -->
  <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'99d5ba394774a49a',t:'MTc2Mjk0NzM0Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>